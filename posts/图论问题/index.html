<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>图论问题 :: shaosy&#39;s blog</title>
  
  <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="图论相对而言比较难......" />
<meta name="keywords" content="图论问题" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://siyangshao.github.io/posts/%E5%9B%BE%E8%AE%BA%E9%97%AE%E9%A2%98/" />




<link rel="stylesheet" href="https://siyangshao.github.io/assets/style.css">

  <link rel="stylesheet" href="https://siyangshao.github.io/assets/green.css">






<link rel="apple-touch-icon" href="https://siyangshao.github.io/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://siyangshao.github.io/img/favicon/green.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="图论问题">
<meta property="og:description" content="图论相对而言比较难......" />
<meta property="og:url" content="https://siyangshao.github.io/posts/%E5%9B%BE%E8%AE%BA%E9%97%AE%E9%A2%98/" />
<meta property="og:site_name" content="shaosy&#39;s blog" />

  <meta property="og:image" content="https://siyangshao.github.io">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-01-31 16:06:52 &#43;0800 CST" />










<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>
<body>
    <div style="position:absolute;right:3%;top:10%;">
        <a id="logo" href="https://siyangshao.github.io"><img
                src="https://firefoxusercontent.com/dbeb73f5ba7f9457d819fa358934828a" width="75%" height="75%" /></a>
    </div>
    <div style="position:absolute;right:3%;top:30%;">
        <h1><a href="https://siyangshao.github.io">shaosy&#39;s blog</a></h1>
    </div>
    <div style="position:absolute;right:7%;top:40%;">
        <h3> <a href="https://github.com/SiyangShao">Github</a>&#160<a href="https://twitter.com/ShaoSiyang">Twitter </a></h3>
    </div>
    <script src="https://siyangshao.github.io/live2d/autoload.js"></script>

</body>
</html>



</head>
<body class="green">


<div class="container headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a
  href="/">
  <div class="logo">
    Main Page
  </div>
</a>

    </div>
    
    <div class="menu-trigger">menu</div>
    
    
  </div>
  
  <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/archive">Archive</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/archive">Archive</a></li>
      
    
    
  </ul>
</nav>

  
</header>

  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://siyangshao.github.io/posts/%E5%9B%BE%E8%AE%BA%E9%97%AE%E9%A2%98/">图论问题</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-01-31 [Updated: 2021-01-31]
      </span>
    
    
    <span class="post-author">:: shaosy</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://siyangshao.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <h1 id="存储">存储<a href="#存储" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="直接存边">直接存边<a href="#直接存边" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> M <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{<span style="color:#66d9ef">int</span> u ,v,w;} e[M];
<span style="color:#66d9ef">int</span> tot;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> u,<span style="color:#66d9ef">int</span> v,<span style="color:#66d9ef">int</span> w){
    e[<span style="color:#f92672">++</span>tot].u<span style="color:#f92672">=</span>u,e[tot].v<span style="color:#f92672">=</span>v,e[tot].w<span style="color:#f92672">=</span>w;
}
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(Edge a , Edge b){
    <span style="color:#66d9ef">return</span> a.w<span style="color:#f92672">&lt;</span>b.w;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#75715e">//add
</span><span style="color:#75715e"></span>    sort(e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>tot,cmp);
}
</code></pre></div><h2 id="邻接矩阵">邻接矩阵<a href="#邻接矩阵" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>优势：便于查询边的存在</p>
<p>但是，很显然， 仅仅在稠密图中这么做较为合理</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> M <span style="color:#f92672">=</span> <span style="color:#ae81ff">520</span>;
<span style="color:#66d9ef">int</span> mp[M][M];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">int</span> n,m;<span style="color:#75715e">//点数，边数
</span><span style="color:#75715e"></span>    cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,u,v,w;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
        cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
        mp[u][v]<span style="color:#f92672">=</span>w;<span style="color:#75715e">//u到v的边边权为w
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//对点x遍历
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> ; i <span style="color:#f92672">&lt;=</span> n ; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span>x){
            <span style="color:#66d9ef">continue</span>;
        }
        <span style="color:#66d9ef">if</span>(mp[x][i]){
            <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>        }
    }
}
</code></pre></div><h2 id="邻接表">邻接表<a href="#邻接表" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>不能快速判断边的存在</p>
<p>判断u-&gt;v边是否存在O(deg+(u))，初始排序后可以做O(log(d+(u)))</p>
<p>遍历点u所有出边O(deg+(u))，</p>
<p>遍历整张图O(n+m)</p>
<p>空间复杂度O(m)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pii;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e4</span><span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>;
vector<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> G[N];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">int</span> n,m;
    cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;<span style="color:#75715e">//点数&amp;边数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ,u,v,w ; i<span style="color:#f92672">&lt;=</span>m ; i<span style="color:#f92672">++</span>){
        cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
        G[u].push_back({v,w});
    }
    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> it:G[x]){
        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> it.first , ww <span style="color:#f92672">=</span> it.second;
        <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><h2 id="链式前向星">链式前向星<a href="#链式前向星" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>不能快速判断边的存在，不方便排序，但是边带有编号，可以得到反边，常常用于网络流</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> M <span style="color:#f92672">=</span> <span style="color:#ae81ff">2e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{<span style="color:#66d9ef">int</span> to , w, nxt;}e[M];
<span style="color:#66d9ef">int</span> h[N],tot;
<span style="color:#66d9ef">void</span> add{<span style="color:#66d9ef">int</span> u , <span style="color:#66d9ef">int</span> v , <span style="color:#66d9ef">int</span> w}{
	e[tot].to <span style="color:#f92672">=</span> v, e[tot].w<span style="color:#f92672">=</span>w;
	e[tot].nxt<span style="color:#f92672">=</span>h[u];<span style="color:#75715e">//连接以u为起点的上一条边
</span><span style="color:#75715e"></span>	h[u]<span style="color:#f92672">=</span>tot<span style="color:#f92672">++</span>;<span style="color:#75715e">//这条边的编号
</span><span style="color:#75715e"></span>}
</code></pre></div><h1 id="拓扑排序">拓扑排序<a href="#拓扑排序" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="kahn算法">KAHN算法：<a href="#kahn算法" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>定义集合S和空序列L，初始为所有入度为0的点，然后S中取出一点加入L，将它的所有出边删除，如果有点入度变为0，则将该点也加入集合S，不断重复直至S为空。若有点不在序列L中，说明图中有环，否则L就是拓扑排序结果</p>
<h3 id="题目">题目：<a href="#题目" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Windy has <em>N</em> balls of distinct weights from 1 unit to <em>N</em> units. Now he tries to label them with 1 to <em>N</em> in such a way that:</p>
<ol>
<li>No two balls share the same label.</li>
<li>The labeling satisfies several constrains like &ldquo;The ball labeled with <em>a</em> is lighter than the one labeled with <em>b&rdquo;.</em></li>
</ol>
<p>Can you help windy to find a solution?</p>
<h3 id="input">Input：<a href="#input" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>The first line of input is the number of test case. The first line of each test case contains two integers, <em>N</em> (1 ≤ <em>N</em> ≤ 200) and <em>M</em> (0 ≤ <em>M</em> ≤ 40,000). The next <em>M</em> line each contain two integers <em>a</em> and <em>b</em> indicating the ball labeled with <em>a</em> must be lighter than the one labeled with <em>b</em>. (1 ≤ <em>a, b</em> ≤ <em>N</em>) There is a blank line before each test case.</p>
<h3 id="output">Output：<a href="#output" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>For each test case output on a single line the balls&rsquo; weights from label 1 to label <em>N</em>. If several solutions exist, you should output the one with the smallest weight for label 1, then with the smallest weight for label 2, then with the smallest weight for label 3 and so on&hellip; If no solution exists, output -1 instead.</p>
<h3 id="sample-input">Sample Input：<a href="#sample-input" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>5

4 0

4 1
1 1

4 2
1 2
2 1

4 1
2 1

4 1
3 2
</code></pre><h3 id="sample-output">Sample Output:<a href="#sample-output" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>1 2 3 4
-1
-1
2 1 3 4
1 3 2 4
</code></pre><h3 id="code">Code:<a href="#code" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> mp[<span style="color:#ae81ff">210</span>][<span style="color:#ae81ff">210</span>];
<span style="color:#66d9ef">int</span> g[<span style="color:#ae81ff">210</span>];
<span style="color:#66d9ef">int</span> T,n,m ,u,v;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Topo</span>(<span style="color:#66d9ef">int</span> n)
{
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span>n;
    <span style="color:#66d9ef">int</span> weight[<span style="color:#ae81ff">210</span>];
    priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&gt;</span>q;
    <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(g[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
            q.push(i);
    }
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()){
        <span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span>q.top();
        q.pop();
        weight[k]<span style="color:#f92672">=</span>cnt<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">if</span>(mp[i][k]){
                g[i]<span style="color:#f92672">--</span>;
                <span style="color:#66d9ef">if</span>(g[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
                    q.push(i);
            }
        }
    }
    <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">else</span>{
        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) {
            cout <span style="color:#f92672">&lt;&lt;</span> weight[i];
            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">!=</span>n){
                cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
            }<span style="color:#66d9ef">else</span>{
                cout<span style="color:#f92672">&lt;&lt;</span>endl;
            }
        }
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    cin<span style="color:#f92672">&gt;&gt;</span>T;
    <span style="color:#66d9ef">while</span>(T<span style="color:#f92672">--</span>){
        cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
        memset(g,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(g));
        memset(mp,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(mp));
        <span style="color:#66d9ef">while</span>(m<span style="color:#f92672">--</span>){
            cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v;
            <span style="color:#66d9ef">if</span>(mp[u][v]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
                mp[u][v]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
                g[u]<span style="color:#f92672">++</span>;
            }
        }
        Topo(n);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="最短路">最短路<a href="#最短路" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="floyd">Floyd<a href="#floyd" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>适用范围：任意两点，复杂度高，常数小</p>
<p>初始已更新集合S包含起点，U包含其它点。 dis[x]表示起点到点 x 的最短距离，每次从U中选出距离最短的点K，删去，并更新各个点到起点的距离，即dis[v]=min(dis[v],dis[K]+COST[K][V])，即通过U中点的最短路径更新相邻点的最短路径，直至所有点更新过。</p>
<h3 id="题目-1">题目：<a href="#题目-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p>
<p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p>
<h3 id="input-1">Input:<a href="#input-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>本题目包含多组数据，请处理到文件结束。
每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。
接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。
再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p>
<h3 id="output-1">Output:<a href="#output-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.</p>
<h3 id="sample-input-1">Sample Input<a href="#sample-input-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>3 3
0 1 1
0 2 3
1 2 1
0 2
3 1
0 1 1
1 2
</code></pre><h3 id="sample-output-1">Sample Output<a href="#sample-output-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>2
-1
</code></pre><h3 id="code-1">Code<a href="#code-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">201</span>;
<span style="color:#66d9ef">int</span> dis[N][N];
<span style="color:#66d9ef">int</span> n,m,s,t;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">while</span>(cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
                dis[i][j] <span style="color:#f92672">=</span> i <span style="color:#f92672">==</span> j <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0x3f3f3f3f</span>;
            }
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, u, v, w; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
            cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w;
            dis[u][v] <span style="color:#f92672">=</span> dis[v][u] <span style="color:#f92672">=</span> min(w, dis[u][v]);
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> n; k<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
                    dis[i][j] <span style="color:#f92672">=</span> min(dis[i][j], dis[i][k] <span style="color:#f92672">+</span> dis[k][j]);
                }
            }
        }
        cin <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">&gt;&gt;</span> t;
        <span style="color:#66d9ef">if</span> (dis[s][t] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        } <span style="color:#66d9ef">else</span> {
            cout <span style="color:#f92672">&lt;&lt;</span> dis[s][t] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        }
    }
}
</code></pre></div><h2 id="最短路bellman-ford">最短路BELLMAN-FORD<a href="#最短路bellman-ford" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>基于松弛操作最短路算法，适用于存在负边权的图上求最短路，也能判断是否存在负权回路</p>
<h3 id="题目-2">题目<a href="#题目-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ&rsquo;s farms comprises <em>N</em> (1 ≤ <em>N</em> ≤ 500) fields conveniently numbered 1..<em>N</em>, <em>M</em> (1 ≤ <em>M</em> ≤ 2500) paths, and <em>W</em> (1 ≤ <em>W</em> ≤ 200) wormholes.</p>
<p>As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .</p>
<p>To help FJ find out whether this is possible or not, he will supply you with complete maps to <em>F</em> (1 ≤ <em>F</em> ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds.</p>
<h3 id="input-2">Input<a href="#input-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Line 1: A single integer, <em>F</em>. <em>F</em> farm descriptions follow.
Line 1 of each farm: Three space-separated integers respectively: <em>N</em>, <em>M</em>, and <em>W</em>
Lines 2..<em>M</em>+1 of each farm: Three space-separated numbers (<em>S</em>, <em>E</em>, <em>T</em>) that describe, respectively: a bidirectional path between <em>S</em> and <em>E</em> that requires <em>T</em> seconds to traverse. Two fields might be connected by more than one path.
Lines <em>M</em>+2..<em>M</em>+<em>W</em>+1 of each farm: Three space-separated numbers (<em>S</em>, <em>E</em>, <em>T</em>) that describe, respectively: A one way path from <em>S</em> to <em>E</em> that also moves the traveler back <em>T</em> seconds.</p>
<h3 id="output-2">Output<a href="#output-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Lines 1..<em>F</em>: For each farm, output &ldquo;YES&rdquo; if FJ can achieve his goal, otherwise output &ldquo;NO&rdquo; (do not include the quotes).</p>
<h3 id="sample-input-2">Sample Input<a href="#sample-input-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>2
3 3 1
1 2 2
1 3 4
2 3 1
3 1 3
3 2 1
1 2 3
2 3 4
3 1 8
</code></pre><h3 id="sample-output-2">Sample Output<a href="#sample-output-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>NO
YES
</code></pre><h3 id="code-2">Code<a href="#code-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">6000</span>;
<span style="color:#66d9ef">int</span> n,m,dis[N],all;
<span style="color:#66d9ef">int</span> t,k;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{<span style="color:#66d9ef">int</span> start,end,to;}e[N];
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">bellman_ford</span>()
{
    <span style="color:#66d9ef">bool</span> flag;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
    {
        flag<span style="color:#f92672">=</span>false;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>all; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(dis[e[j].end] <span style="color:#f92672">&gt;</span> dis[e[j].start] <span style="color:#f92672">+</span> e[j].to)
            {
                dis[e[j].end] <span style="color:#f92672">=</span> dis[e[j].start] <span style="color:#f92672">+</span> e[j].to ;
                flag<span style="color:#f92672">=</span>true;
            }

        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>flag)<span style="color:#66d9ef">break</span>;
    }
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>all; j<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(dis[e[j].end] <span style="color:#f92672">&gt;</span> dis[e[j].start] <span style="color:#f92672">+</span> e[j].to)
            <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">return</span> false;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    cin<span style="color:#f92672">&gt;&gt;</span>t;
    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> k;
        memset(dis, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span>(dis));
        memset(e,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(e));
        all <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, u, v, w; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
            cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w;
            e[all].start<span style="color:#f92672">=</span>e[all<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].end<span style="color:#f92672">=</span>u;
            e[all].end<span style="color:#f92672">=</span>e[all<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].start<span style="color:#f92672">=</span>v;
            e[all].to<span style="color:#f92672">=</span>e[all<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].to<span style="color:#f92672">=</span>w;
            all<span style="color:#f92672">+=</span><span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span>  <span style="color:#ae81ff">0</span>, u, v, w; i <span style="color:#f92672">&lt;</span>  k; i<span style="color:#f92672">++</span>) {
            cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w;
            e[all].start <span style="color:#f92672">=</span> u;
            e[all].end <span style="color:#f92672">=</span> v;
            e[all].to <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>w;
            all<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">if</span>(bellman_ford()){
            cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;YES</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        }<span style="color:#66d9ef">else</span>{
            cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        }
    }
}
</code></pre></div><h1 id="网络流">网络流<a href="#网络流" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>网络是指一个有向图，每条边都有一个容量 (cap) 和实际流量 (flow) 。</p>
<p>图中有源点S、汇点T，除源点和汇点之外流入所有其他点的流量一定等于流出该节点的流量（不会凭空产生流量）</p>
<p>总流量：源点的输出/汇点的输入</p>
<p>最大流：从源点S流向汇点T的最大流量</p>
<p>最小割：是割掉 M 条边来让源点S跟汇点T不互通，要求M条边加起来的流量总和最小。</p>
<p>费用流：每条边都有单位流量流过的开销，要在求出最大流的同时，要求花费的费用最小。</p>
<h3 id="题目-3">题目<a href="#题目-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Network flow is a well-known difficult problem for ACMers. Given a graph, your task is to find out the maximum flow for the weighted directed graph.</p>
<h3 id="input-3">Input<a href="#input-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>The first line of input contains an integer T, denoting the number of test cases.
For each test case, the first line contains two integers N and M, denoting the number of vertexes and edges in the graph. (2 &lt;= N &lt;= 15, 0 &lt;= M &lt;= 1000)
Next M lines, each line contains three integers X, Y and C, there is an edge from X to Y and the capacity of it is C. (1 &lt;= X, Y &lt;= N, 1 &lt;= C &lt;= 1000)</p>
<h3 id="output-3">Output<a href="#output-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>For each test cases, you should output the maximum flow from source 1 to sink N.</p>
<h3 id="sample-input-3">Sample Input<a href="#sample-input-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>2
3 2
1 2 1
2 3 1
3 3
1 2 1
2 3 1
1 3 1
</code></pre><h3 id="sample-output-3">Sample Output<a href="#sample-output-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre><code>Case 1: 1
Case 2: 2
</code></pre><h3 id="code-3">Code<a href="#code-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn<span style="color:#f92672">=</span><span style="color:#ae81ff">205</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> inf<span style="color:#f92672">=</span><span style="color:#ae81ff">0x7fffffff</span>;

<span style="color:#66d9ef">int</span> r[maxn][maxn]; <span style="color:#75715e">//残留网络，初始化为原图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> visit[maxn];
<span style="color:#66d9ef">int</span> pre[maxn];
<span style="color:#66d9ef">int</span> m,n;
<span style="color:#66d9ef">int</span> t;
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> s,<span style="color:#66d9ef">int</span> t) <span style="color:#75715e">//寻找一条从s到t的增广路，若找到返回true
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> p;
    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&gt;</span> q;
    memset(pre,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(pre));
    memset(visit,false,<span style="color:#66d9ef">sizeof</span>(visit));

    pre[s]<span style="color:#f92672">=</span>s;
    visit[s]<span style="color:#f92672">=</span>true;
    q.push(s);
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
    {
        p<span style="color:#f92672">=</span>q.front();
        q.pop();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">if</span>(r[p][i]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&amp;&amp;!</span>visit[i])
            {
                pre[i]<span style="color:#f92672">=</span>p;
                visit[i]<span style="color:#f92672">=</span>true;
                <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> true;
                q.push(i);
            }
        }
    }
    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">EdmondsKarp</span>(<span style="color:#66d9ef">int</span> s,<span style="color:#66d9ef">int</span> t)
{
    <span style="color:#66d9ef">int</span> flow<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,d,i;
    <span style="color:#66d9ef">while</span>(bfs(s,t))
    {
        d<span style="color:#f92672">=</span>inf;
        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span>t;i<span style="color:#f92672">!=</span>s;i<span style="color:#f92672">=</span>pre[i])
            d<span style="color:#f92672">=</span>d<span style="color:#f92672">&lt;</span>r[pre[i]][i]<span style="color:#f92672">?</span> d:r[pre[i]][i];
        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span>t;i<span style="color:#f92672">!=</span>s;i<span style="color:#f92672">=</span>pre[i])
        {
            r[pre[i]][i]<span style="color:#f92672">-=</span>d;
            r[i][pre[i]]<span style="color:#f92672">+=</span>d;
        }
        flow<span style="color:#f92672">+=</span>d;
    }
    <span style="color:#66d9ef">return</span> flow;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    cin<span style="color:#f92672">&gt;&gt;</span>t;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> ; i <span style="color:#f92672">&lt;=</span> t ; i<span style="color:#f92672">++</span>) {
        cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
        <span style="color:#66d9ef">int</span> u, v, w;
        memset(r, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(r));<span style="color:#75715e">///
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
            scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v, <span style="color:#f92672">&amp;</span>w);
            r[u][v] <span style="color:#f92672">+=</span> w;
        }
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Case &#34;</span><span style="color:#f92672">&lt;&lt;</span>i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;: &#34;</span><span style="color:#f92672">&lt;&lt;</span>EdmondsKarp(<span style="color:#ae81ff">1</span>, n)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#39;\n&#39;</span>;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://siyangshao.github.io/posts/202102/">
                <span class="button__icon">←</span>
                <span class="button__text">202102</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="https://siyangshao.github.io/posts/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/">
                <span class="button__text">博弈问题</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2021 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://siyangshao.github.io/assets/main.js"></script>
<script src="https://siyangshao.github.io/assets/prism.js"></script>







  
</div>

</body>
</html>
